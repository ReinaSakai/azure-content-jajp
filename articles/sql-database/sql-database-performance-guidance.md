<properties
	pageTitle="データベースが 1 台の場合の Azure SQL Database のパフォーマンス ガイダンス"
	description="このトピックでは、お使いのアプリケーションに最適なサービス層を決める際の指針と Azure SQL Database を最大限活用するためにアプリケーションを調整する際の推奨事項について説明します。"
	services="sql-database"
	documentationCenter="na"
	authors="CarlRabeler"
	manager="jhubbard"
	editor="" />


<tags
	ms.service="sql-database"
	ms.devlang="na"
	ms.topic="article"
	ms.tgt_pltfrm="na"
	ms.workload="data-management"
	ms.date="09/13/2016"
	ms.author="carlrab" />

# データベースが 1 台の場合の Azure SQL Database のパフォーマンス ガイダンス

## Overview

Microsoft Azure SQL Database には 3 つの[サービス層](sql-database-service-tiers.md)があります。Basic、Standard、Premium です。すべてのサービス層で、Azure SQL Database に与えられたリソースが厳密に分離され、パフォーマンスが予測可能になります。パフォーマンスの測定単位は DTU です。DTU の詳細については、[DTU](sql-database-what-is-a-dtu.md) に関するトピックを参照してください。この記事では、アプリケーションに最適なサービス レベルを選ぶためのガイダンスと Azure SQL Database を最大限活用するためにアプリケーションを調整する際の推奨事項について説明します。

>[AZURE.NOTE] この記事では、SQL Database のデータベースが 1 台の場合のパフォーマンスについて説明しまするエラスティック プールに関連するパフォーマンス ガイダンスについては、[エラスティック プールの価格とパフォーマンスに関する考慮事項](sql-database-elastic-pool-guidance.md)に関するトピックを参照してください。ただし、この記事にある、データベースが 1 つの場合の調整事項の多くは、パフォーマンス上の長所が同じエラスティック プール内のデータベースに適用できます。

- **Basic**: Basic サービス レベルは、各データベースのパフォーマンスを時間単位で予測できるように設計されています。Basic データベースの DTU は、複数の同時要求がない、小規模のデータベースに十分なリソースを与えるように設計されています。
- **Standard**: Standard サービス レベルではパフォーマンス予測機能が上がっており、ワークグループや Web アプリケーションなど、複数の同時要求があるデータベースに対応します。Standard サービス層のデータベースを使用すると、分単位の予測可能パフォーマンスに基づいてデータベース アプリケーションをサイズ調整できます。
- **Premium**: Premium サービス レベルでは、Premium データベースごとに秒単位で予測できるパフォーマンスが提供されます。Premium サービス層を利用すれば、データベースのピーク負荷に基づいてデータベース アプリケーションのサイズを調整し、パフォーマンス差異に起因し、待ち時間が重要な操作で予想以上の時間が小規模クエリにかかる事態をなくすることができます。このモデルは、ピーク時のリソース ニーズ、パフォーマンス差異、クエリ待ち時間を高い確率で予測するために必要なアプリケーションの開発と製品検証の周期を大幅に単純化できます。

各サービス レベルのパフォーマンス レベル設定では、必要とする容量の分だけ支払い、ワークロードの変化に合わせて容量を[増減](sql-database-scale-up.md)できます。たとえばに、新学期のお買い物シーズンにデータベースの作業負荷がビジー状態になる場合、その期間、データベースのパフォーマンス レベルを増やし、ピーク期間が過ぎたら、減らすなどできます。ビジネスの季節性に合わせてクラウド環境を最適化することで、支払いを最小限に抑えることができます。このモデルはソフトウェア製品のリリース周期にも適しています。テスト チームは、テストの実行中に容量を割り当て、テストが完了したらその容量を解放できます。このような容量要求は、使われることがほとんどない専用のリソースに対する支出を回避して、必要な分の容量に対して支払うモデルに適しています。

## サービス層を使用する理由

それぞれのワークロードが変化する中でサービス レベルを使用する目的は、各種のパフォーマンス レベルでパフォーマンス予測可能性を提供することにあります。データベースのリソース要件が大規模になるお客様は、より専用度の高いコンピューティング環境で作業できます。

### Basic サービス層の使用例:

- **Azure SQL Database の概要**: 多くの場合、開発中のアプリケーションは高いレベルのパフォーマンスを必要としません。Basic データベースは、低価格でデータベースを開発するための理想的な環境となります。
- **ユーザーが 1 人のデータベース**: 1 人のユーザーがデータベースに関連付けられるアプリケーションでは通常、同時性とパフォーマンスの要件が高くなりません。そのような要件のアプリケーションの場合、Basic サービス層が候補となります。

### Standard サービス層の使用例:

- **複数の同時要求を持つデータベース**: 一度に複数のユーザーにサービスを提供するアプリケーション。たとえば、トラフィック量が中程度の Web サイトや大量のリソースを必要とする部門用アプリケーションには、Stardard サービス レベルが候補として適しています。

### Premium サービス層の使用例:

- **高ピーク負荷**: 操作を完了するためにたくさんの CPU、メモリ、IO を必要とするアプリケーション。たとえば、長時間にわたって複数の CPU コアが使用されることがわかっているデータベース操作を使用する場合は、Premium サービス レベルが候補となります。
- **多くの同時要求**: トラフィック量が多い Web サイトにサービスを提供するなど、一部のデータベース アプリケーションは多くの同時要求にサービスを提供します。Basic サービス レベルと Standard サービス レベルの場合、同時要求の数に制限があります。アプリケーションが多くの接続を必要とするとき、場合によっては、必要な要求の最大数を処理するための予約サイズを選択する必要があります。
- **短い待ち時間**: 一部のアプリケーションでは、データベースから応答時間を最小限にする必要があります。お客様側の操作の一部として所与のストアド プロシージャが呼び出されるとき、99% の割合で 20 ミリ秒以内にその呼び出しから返すことが場合によっては要求されます。この種のアプリケーションでは、Premium サービス レベルを利用すれば、コンピューティング パワーが確実に得られます。

必要となる厳密なレベルは、リソース次元ごとのピーク負荷要件に基づきます。アプリケーションによっては、あるリソースについてはほとんど使用しない一方で、他のリソースは大量に使用するものがあります。

## 課金と価格情報

エラスティック プールは、次の特性ごとに課金されます。

- エラスティック プールは、プールにデータベースがない場合でも、その作成時に課金されます。
- エラスティック プールは 1 時間ごとに課金されます。この測定頻度は、シングル データベースのパフォーマンス レベル間で同じです。
- エラスティック プールが新しい eDTU 量にサイズ変更されると、サイズ変更操作が完了するまでは新しい eDTU 量に応じた課金はされません。この課金パターンは、スタンドアロン データベースのパフォーマンス レベルを変更する場合と同様のパターンに従っています。


- エラスティック プールの価格は、プールの eDTU 数に基づきます。エラスティック プールの価格は、内部のエラスティック データベースの使用率とは関係ありません。
- 価格は、(プールの eDTU 数) x (eDTU あたりの単価) で計算されます。

エラスティック プールの eDTU 単価は、同じサービス階層のスタンドアロン データベースの DTU 単価よりも高くなります。詳細については、「[SQL Database の価格](https://azure.microsoft.com/pricing/details/sql-database/)」をご覧ください。

## サービス層の機能と制限
各サービス層とパフォーマンス レベルは、さまざまな制限やパフォーマンス特性に関連付けられています。次の表は、単一データベースの特性についてまとめたものです。

[AZURE.INCLUDE [SQL DB のサービス階層表](../../includes/sql-database-service-tiers-table.md)]

以降のセクションでは、これらの制限に関連する使用状況の表示方法について詳しく説明します。

### 最大インメモリ OLTP ストレージ

**sys.dm\_db\_resource\_stats** ビューを使用して、インメモリ ストレージの使用状況を監視できます。監視の詳細については、「[OLTP インメモリ ストレージを監視する](sql-database-in-memory-oltp-monitoring.md)」を参照してください。

>[AZURE.NOTE] メモリ内 OLTP プレビューは現在のところ、単一データベースでのみサポートされており、エラスティック データベース プールのデータベースではサポートされていません。

### 最大同時要求数

同時要求の数を確認するには、SQL データベースで次の Transact-SQL クエリを実行します。

	SELECT COUNT(*) AS [Concurrent_Requests]
	FROM sys.dm_exec_requests R

オンプレミス SQL Server データベースの作業負荷を分析している場合、分析している特定のデータベースでフィルター処理するようにこのクエリを変更してください。たとえば、MyDatabase という名前のオンプレミス データベースがある場合、次の Transact-SQL クエリはそのデータベースの同時要求数を返します。

	SELECT COUNT(*) AS [Concurrent_Requests]
	FROM sys.dm_exec_requests R
	INNER JOIN sys.databases D ON D.database_id = R.database_id
	AND D.name = 'MyDatabase'

これはある時点のスナップショットにすぎません。作業負荷をさらに詳しく理解するには、長期間のたくさんのサンプルを集め、同時要求要件を理解する必要があります。

### 最大同時ログイン数

同時ログイン数または履歴を表示するクエリや DMV はありません。ユーザーやアプリケーションのパターンを分析すれば、ログインの頻度を理解できます。テスト環境で実世界の負荷を実行し、この上限やこのトピックで説明されている他の制限に達していないことを確認できます。

複数のクライアントで同じ接続文字列を使用している場合、サービスによってそれぞれのログインが認証されます。10 人のユーザーが同じユーザー名とパスワードでデータベースに同時に接続した場合、10 件の同時ログインが発生します。この制限は、ログインと認証の期間のみに適用されます。そのため、同じ 10 人のユーザーがデータベースに順番に接続した場合、同時ログイン数が 1 より大きくなることはありません。

>[AZURE.NOTE] この制限は現在のところ、エラスティック データベース プールのデータベースには適用されません。

### 最大セッション数

現在のアクティブなセッション数を確認するには、SQL データベースで次の Transact-SQL クエリを実行します。

	SELECT COUNT(*) AS [Sessions]
	FROM sys.dm_exec_connections

オンプレミス SQL Server の作業負荷を分析している場合、特定のデータベースに焦点を当てるようにクエリを変更してください。このクエリは、データベースを Azure SQL Database に移行した場合のデータベースの潜在的なセッション ニーズを調べるのに役立ちます。

	SELECT COUNT(*)  AS [Sessions]
	FROM sys.dm_exec_connections C
	INNER JOIN sys.dm_exec_sessions S ON (S.session_id = C.session_id)
	INNER JOIN sys.databases D ON (D.database_id = S.database_id)
	WHERE D.name = 'MyDatabase'

ここでも、これらのクエリはある時点の検数を返します。つまり、長期間、複数のサンプルを集めることで、セッション使用を正確に理解できます。

SQL Database 分析の場合、**sys.resource\_stats** にクエリを実行し、セッションの過去の統計値を取得することもできます。**active\_session\_count** 列を利用します。次の監視セクションで、このビューの利用に関する詳細を提供します。

## リソース使用の監視
SQL データベースのリソース使用をそのサービス層との関連で監視できるビューが 2 つあります。

- [sys.dm\_db\_resource\_stats](https://msdn.microsoft.com/library/dn800981.aspx)
- [sys.resource\_stats](https://msdn.microsoft.com/library/dn269979.aspx)

### sys.dm\_db\_resource\_stats の使用
[sys.dm\_db\_resource\_stats](https://msdn.microsoft.com/library/dn800981.aspx) ビューは各 SQL データベースにあり、サービス層との関連で最近リソース使用率データを提供します。CPU、データ IO、ログ書き込み、メモリの平均 (%) が 15 秒ごとに記録され、1 時間保持されます。

このビューにはリソース使用率が詳細に表示されるので、現状の分析やトラブルシューティングの場合、最初に「**sys.dm\_db\_resource\_stats**」を利用してください。たとえば、次のクエリは、この 1 時間の現在のデータベースの平均リソース使用率と最大リソース使用率を表示します。

	SELECT  
	    AVG(avg_cpu_percent) AS 'Average CPU Utilization In Percent',
	    MAX(avg_cpu_percent) AS 'Maximum CPU Utilization In Percent',
	    AVG(avg_data_io_percent) AS 'Average Data IO In Percent',
	    MAX(avg_data_io_percent) AS 'Maximum Data IO In Percent',
	    AVG(avg_log_write_percent) AS 'Average Log Write Utilization In Percent',
	    MAX(avg_log_write_percent) AS 'Maximum Log Write Utilization In Percent',
	    AVG(avg_memory_usage_percent) AS 'Average Memory Usage In Percent',
	    MAX(avg_memory_usage_percent) AS 'Maximum Memory Usage In Percent'
	FROM sys.dm_db_resource_stats;  

その他のクエリについては、[sys.dm\_db\_resource\_stats](https://msdn.microsoft.com/library/dn800981.aspx) の例を参照してください。

### sys.resource\_stats の使用

**マスター** データベースの [sys.resource\_stats](https://msdn.microsoft.com/library/dn269979.aspx) ビューには、特定のサービス層とパフォーマンス レベルで SQL データベースを監視するための追加情報があります。データは 5 分ごとに集められ、約 35 日間保存されます。このビューは、SQL データベースの過去のリソース使用率を長期にわたり分析する際に役立ちます。

次のグラフは、Premium データベースの CPU リソース使用率を示しています (P2 パフォーマンス レベル、1 週間における毎時間の使用率)。このグラフは月曜日から始まります。5 営業日が経過した後の週末ではアプリケーションの活動が大幅に減っていることがわかります。

![SQL DB リソース使用率](./media/sql-database-performance-guidance/sql_db_resource_utilization.png)

このデータから、このデータベースのピーク CPU 負荷は現在のところ、P2 パフォーマンス レベルに対して 50% をわずかに超える CPU 利用率になっていることがわかります (火曜日の昼)。アプリケーションのリソース プロファイルにおいて CPU が支配的要因になる場合、P2 が作業負荷に常に対処できる最適なパフォーマンス レベルであると決定できます。アプリケーションで時間と共に増加が予測される場合、上限に到達しないように、余分にリソース バッファーを考慮すると合理的です。パフォーマンス レベルを上げることで、特に待ち時間が重要になる環境において、データベース (たとえば、データベース呼び出しの結果に基づいて Web ページを表示するアプリケーションをサポートするデータベース) が要求を効果的に処理するのに十分なパワーが足りないことが原因で発生する、ユーザーが識別できるエラーを回避できます。

アプリケーションの種類が異なれば、同じグラフの解釈が異なることにも注意してください。たとえば、あるアプリケーションが給与データを毎日処理し、同じグラフを生成する場合、P1 パフォーマンス レベルでこの種の "一括ジョブ" モデルに問題なく対応できる可能性があります。P1 パフォーマンス レベルの DTU は 100 で、P2 パフォーマンス レベルの DTU は 200 です。つまり、P1 パフォーマンス レベルのパフォーマンスは P2 パフォーマンス レベルの半分となります。そのため、P2 の 50% CPU 使用は P1 の 100% CPU 使用に等しくなります。アプリケーションにタイムアウトがない限り、当日に完了するのであれば、ジョブに 2 時間かかっても 2.5 時間かかっても問題ないでしょう。このカテゴリのアプリケーションは、おそらく、P1 パフォーマンス レベルを利用できます。1 日の中にはリソース使用率が低くなる時間帯があるという事実を利用できます。つまり、"大きなピーク" が 1 日のそのような時間帯のいずれかに波及することがあります。ジョブを毎日定刻で完了できる限り、P1 パフォーマンス レベルがこのようなアプリケーションに最適化もしれません (さらにコストを削減します)。

Azure SQL Database では、各サーバーの**マスター** データベースの **sys.resource\_stats** ビューにアクティブなデータベース別のリソース利用情報が公開されます。テーブルのデータは 5 分おきに集計されます。Basic、Standard、および Premium のサービス レベルでは、データをテーブルに表示するのに 5 分を超える時間がかかる可能性があります。つまり、このデータはほぼリアルタイムの分析より過去の分析に適しています。**sys.resource\_stats** ビューに問い合わせると、データベースの最近の履歴が表示され、選択した予約で必要なときに望ましいパフォーマンスが届けられたか検証されます。

>[AZURE.NOTE] 次の例で **sys.resource\_stats** を照会するためには、論理 SQL Database サーバーの**マスター** データベースに接続する必要があります。

次の例は、このビューのデータが公開されるしくみを示しています。

	SELECT TOP 10 *
	FROM sys.resource_stats
	WHERE database_name = 'resource1'
	ORDER BY start_time DESC

![システム リソース統計](./media/sql-database-performance-guidance/sys_resource_stats.png)

次の例では、**sys.resource\_stats** カタログ ビューを使用して、SQL データベースのリソース使用率を理解するためのさまざまな方法を示します。

1. たとえば、「userdb1」という名前のデータベースの先週のリソース利用率を調べる場合、次のクエリを実行できます。

		SELECT *
		FROM sys.resource_stats
		WHERE database_name = 'userdb1' AND
		      start_time > DATEADD(day, -7, GETDATE())
		ORDER BY start_time DESC;

2. 作業負荷がパフォーマンス レベルに適合する様子を評価するために、さまざまなリソース指標 (CPU、読み取り、書き込み、ワーカー数、セッション数) で分析する必要があります。次に、sys.resource\_stats を使用してこれらのリソース指標の平均値と最大値を報告するように修正したクエリを示します。

		SELECT
		    avg(avg_cpu_percent) AS 'Average CPU Utilization In Percent',
		    max(avg_cpu_percent) AS 'Maximum CPU Utilization In Percent',
		    avg(avg_data_io_percent) AS 'Average Physical Data IO Utilization In Percent',
		    max(avg_data_io_percent) AS 'Maximum Physical Data IO Utilization In Percent',
		    avg(avg_log_write_percent) AS 'Average Log Write Utilization In Percent',
		    max(avg_log_write_percent) AS 'Maximum Log Write Utilization In Percent',
		    avg(max_session_percent) AS 'Average % of Sessions',
		    max(max_session_percent) AS 'Maximum % of Sessions',
		    avg(max_worker_percent) AS 'Average % of Workers',
		    max(max_worker_percent) AS 'Maximum % of Workers'
		FROM sys.resource_stats
		WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());

3. 各リソース指標の平均値と最大値に関する上記の情報に基づいて、選択したパフォーマンス レベルにワークロードが適合しているかどうかを評価できます。通常、sys.resource\_stats からの平均値が目標サイズに対する有効な基準となります。これを主要なものさしとしてください。たとえば、S2 パフォーマンス レベルで Standard サービス レベルを使用しているときに CPU と I/O の読み取り/書き込みの平均使用率が 40% を下回り、ワーカーの平均数が 50 を下回り、セッションの平均数が 200 を下回る場合、このワークロードには S1 パフォーマンス レベルが適している可能性があります。データベースがワーカーとセッションの制限内に収まるかどうかが簡単にわかります。CPU、読み取り、書き込みに関して、データベースが下位のパフォーマンス レベルに適合するかどうかを確認するには、下位パフォーマンス レベルの DTU 数を現在のパフォーマンス レベルの DTU 数で割り、その計算結果に 100 を掛けます。

	**S1 DTU / S2 DTU * 100 = 20 / 50 * 100 = 40**

	この結果は、2 つのパフォーマンス レベルの間の相対的パフォーマンス差異を百分率で表したものになります。利用率がこの割合を超えていない場合、その作業負荷には下位のパフォーマンス レベルが適しているかもしれません。ただし、リソース利用率の値を全範囲で見て、割合の観点で、どのくらいの頻度でデータベースの作業負荷が下位のパフォーマンス レベルに適合するかを判断する必要もあります。次のクエリは、前に計算された 40% のしきい値に基づき、リソース次元別の適合率を出力します。

		SELECT
		    (COUNT(database_name) - SUM(CASE WHEN avg_cpu_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'CPU Fit Percent'
		    ,(COUNT(database_name) - SUM(CASE WHEN avg_log_write_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Log Write Fit Percent'
		    ,(COUNT(database_name) - SUM(CASE WHEN avg_data_io_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Physical Data IO Fit Percent'
		FROM sys.resource_stats
		WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());

	データベースのサービス レベル目標 (SLO) に基づき、作業負荷が下位のパフォーマンス レベルに適合するかどうかを判断できます。データベース ワークロード SLO が 99.9% で、上のクエリが 3 つのすべてのリソース次元に対して 99.9 を超える値を返す場合、そのワークロードはおそらく下位のパフォーマンス レベルに適合します。

	適合率を見ると、SLO を満たすために上位のパフォーマンス レベルに移るべきかどうかもわかります。たとえば、「userdb1」は先週の次の使用率を示しています。

	| 平均 CPU パーセント | 最大 CPU パーセント |
	|---|---|
	| 24\.5 | 100\.00 |

	平均 CPU はパフォーマンス レベルの上限の約 4 分の 1 になり、データベースのパフォーマンス レベルにうまく適合でしょう。ただし、最大値はデータベースがパフォーマンス レベルの上限に到達することを示します。次に上位のパフォーマンス レベルに移動する必要がありますか。 この場合も、作業負荷が 100% に到達する回数を見て、それをデータベース作業負荷 SLO と比較する必要があります。

		SELECT
		(COUNT(database_name) - SUM(CASE WHEN avg_cpu_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'CPU Fit Percent'
		,(COUNT(database_name) - SUM(CASE WHEN avg_log_write_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Log Write Fit Percent’
		,(COUNT(database_name) - SUM(CASE WHEN avg_data_io_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Physical Data IO Fit Percent'
		FROM sys.resource_stats
		WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());

	このクエリが 3 つのリソース次元のいずれにも 99.9% 未満の値を返す場合、次の上位のパフォーマンス レベルに移動するか、アプリケーションの調整手法を使用して Azure SQL Database の負荷を減らすことを検討してください。

4. 前の演習では、将来的に予測されるワークロードの増加も考慮しています。

## アプリケーションの調整

従来のオンプレミス SQL Server では、初回の容量計画のプロセスは、多くの場合、アプリケーションを本稼働実行するプロセスとは分けられます。言い換えると、SQL Server を実行するためのハードウェアと関連ライセンスの購入は前もって行われ、パフォーマンス調整は後で行われます。Azure SQL Database を使用する場合は、アプリケーションの実行と調整のプロセスを交互に行うことをお勧めします (毎月請求されるため、おそらくはこれが望ましくなります)。オンデマンド容量の支払いモデルでは、アプリケーションの将来的な成長計画の推測に基づいてハードウェアに大規模な過剰プロビジョニングを行う代わりに (はるか先の将来まで予測する必要があるため、多くの場合、この方法は正しくありません)、現在必要とされる最小リソースを使用するようにアプリケーションを調整できます。アプリケーションを調整せず、代わりにハードウェア リソースを過剰にプロビジョニングすることを選ぶユーザーもいます。そのような手法は、ある重要なアプリケーションの利用が集中する期間にそのアプリケーションを変更が望まれない場合に有効です。アプリケーションを調整することで、リソース要件を最小限に抑え、Azure SQL Database のサービス層を使用するとき、毎月の請求額を抑えます。

### アプリケーションの特性

サービス レベルはアプリケーションのパフォーマンスの安定性と予測可能性を高めるように設計されています。その一方で、パフォーマンス レベル内でリソースを最大限に活用するためのアプリケーションの調整に関して、いくつかのベスト プラクティスが存在します。上位のパフォーマンス レベルまたはサービス レベルに切り替えることで、多くのアプリケーションでパフォーマンスが大幅に上がりますが、アプリケーションによっては、さらに調整しなければ効果が得られない場合もあります。アプリケーションに次の特性がある場合、Azure SQL Database の使用時のパフォーマンスを改善する目的で、追加のアプリケーション調整も考慮してください。

- **"chatty (煩雑な)" 動作が原因でパフォーマンスの低いアプリケーション**: 煩雑なアプリケーションでは、ネットワークの待ち時間が重要となるデータ アクセス操作が過度に発生します。そのようなアプリケーションでは、場合によっては、Azure SQL Database にデータ アクセスする操作の数を減らす修正が必要になります。たとえば、アドホック クエリをまとめて処理したり、ストアド プロシージャにクエリを移動したりするなどの手法でアプリケーション パフォーマンスが向上する可能性があります。詳細については、後続の「クエリの一括処理」セクションを参照してください。
- **集中的な作業負荷を 1 台のコンピューター全体で処理できないデータベース**: Premium の最高レベルのパフォーマンスのリソースを超えるデータベースは最良の候補ではありません。このようなデータベースは、作業負荷をスケールアウトすることで改善することがあります。詳細については、後続の「データベース間のシャーディング」セクションと「機能的パーティション分割」セクションを参照してください。
- **最適ではないクエリを含むアプリケーション**: 特にデータ アクセス層の、クエリが十分に調整されていないアプリケーションの場合、上位のパフォーマンス レベルを選択しても期待したような効果が得られない可能性があります。たとえば、WHERE 句がない、インデックスが足りない、統計が古いクエリです。このようなアプリケーションの場合、クエリ パフォーマンスの標準的な調整方法で効果が得られます。詳細については、後続の「インデックスの不足」セクションと「クエリの調整/ヒント」を参照してください。
- **データ アクセス設計が最適ではないアプリケーション**: デッドロックなど、データ アクセスの同時性問題が内在するアプリケーションの場合、上位のパフォーマンス レベルを選択しても効果が得られないことがあります。アプリケーションの開発者は、Azure Caching サービスや他のキャッシング技術を利用し、クライアント側でデータをキャッシュすることで Azure SQL Database に対するラウンドトリップを減らすことを検討してください。後続の「アプリケーション層のキャッシング」セクションを参照してください。

## 調整技法
このセクションでは、 Azure SQL Database を調整し、アプリケーションから最良のパフォーマンスを引き出し、可能な限り下位のパフォーマンス レベルで実行するための手法について説明します。これらの手法のいくつかは従来の SQL Server 調整のベスト プラクティスと同じものですが、一部の手法は Azure SQL Database に固有です。従来の SQL Server 手法を拡大し、Azure SQL Database に応用することもできます。その場合、データベースに利用されるリソースを調べ、さらに細かく調整するべき領域を見つけます。

### Query Performance Insight と SQL Database Advisor
SQL Database は Azure Portal でデータベースのパフォーマンス問題を分析し、解消するための 2 つのツールを提供します。

- [Query Performance Insight](sql-database-query-performance.md)
- [SQL Database Advisor](sql-database-advisor.md)

各ツールの概要とその使用方法については、前のリンクを参照してください。インディクスの不足とクエリの調整に関する次の 2 つのセクションでは、同様のパフォーマンス問題を手動で見つけ、修正するためのその他の方法を提供します。最初にポータルのツールを試し、より効率的に診断し、問題を解消することをお勧めします。特別なケースで手動の調整方法を利用してください。

### インデックスの不足
OLTP データベースのパフォーマンスの一般的問題は物理的なデータベース設計に関連します。多くの場合、データベース スキーマは (負荷またはデータ量の) 規模の面で試験することなく設計され、出荷されます。残念ながら、クエリ プランのパフォーマンスは小規模で許容される場合がありますが、実稼働レベルのデータ量に直面したときに大幅が低下する可能性があります。この問題の最も一般的な原因は、適切なインデックスがなく、クエリのフィルターまたはその他の制約を満たせないことにあります。多くの場合、インデックスがないと、インデックス シークで足りるときにテーブル スキャンが行われます。

次の例では、シークで足りるとき、選択したクエリ プランにスキャンが含まれます。

	DROP TABLE dbo.missingindex;
	CREATE TABLE dbo.missingindex (col1 INT IDENTITY PRIMARY KEY, col2 INT);
	DECLARE @a int = 0;
	SET NOCOUNT ON;
	BEGIN TRANSACTION
	WHILE @a < 20000
	BEGIN
	    INSERT INTO dbo.missingindex(col2) VALUES (@a);
	    SET @a += 1;
	END
	COMMIT TRANSACTION;
	GO
	SELECT m1.col1
	FROM dbo.missingindex m1 INNER JOIN dbo.missingindex m2 ON(m1.col1=m2.col1)
	WHERE m1.col2 = 4;

![インデックス不足のクエリ プラン](./media/sql-database-performance-guidance/query_plan_missing_indexes.png)

Azure SQL Database には、データベース管理者が一般的なインデックス不足状態を発見し、修正するときに役立つ機能があります。Azure SQL Database に組み込まれている動的管理ビュー (DMV) には、クエリ コンパイルが表示されます。クエリを実行するために見積もられたコストをクエリで大幅に削減できる場合があります。クエリの実行中、SQL Database により、各クエリ プランが実行される頻度と、実行クエリ プランとそのインデックスが存在した想定クエリ プランの間で見積もられるギャップが追跡記録されます。これらの DMV により、データベース管理者は、所与のデータベースとその実際のワークロードに対して、全体的なワークロード コストを改善できる可能性がある物理的データベース設計変更をすばやく推測できます。

次のクエリは潜在的なインデックス不足の評価に使用できます。

	SELECT CONVERT (varchar, getdate(), 126) AS runtime,
	    mig.index_group_handle, mid.index_handle,
	    CONVERT (decimal (28,1), migs.avg_total_user_cost * migs.avg_user_impact *
	            (migs.user_seeks + migs.user_scans)) AS improvement_measure,
	    'CREATE INDEX missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' +
	              CONVERT (varchar, mid.index_handle) + ' ON ' + mid.statement + '
	              (' + ISNULL (mid.equality_columns,'')
	              + CASE WHEN mid.equality_columns IS NOT NULL
	                          AND mid.inequality_columns IS NOT NULL
	                     THEN ',' ELSE '' END + ISNULL (mid.inequality_columns, '')
	              + ')'
	              + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement,
	    migs.*,
	    mid.database_id,
	    mid.[object_id]
	FROM sys.dm_db_missing_index_groups AS mig
	INNER JOIN sys.dm_db_missing_index_group_stats AS migs
	    ON migs.group_handle = mig.index_group_handle
	INNER JOIN sys.dm_db_missing_index_details AS mid
	    ON mig.index_handle = mid.index_handle
	ORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC

この例では、次のインデックスが提案されました。

	CREATE INDEX missing_index_5006_5005 ON [dbo].[missingindex] \([col2])  

作成後、その同じ SELECT ステートメントが今度は、スキャンの代わりに、シークを使用する別の計画を選択します。次のクエリ プランのように、より効率的に実行されます。

![インデックスが修正されたクエリ プラン](./media/sql-database-performance-guidance/query_plan_corrected_indexes.png)

重要なことは、共有される商品システムの IO 容量は専用サーバー コンピューターより限られるということです。不必要な I/O を最小限に抑え、Azure SQL Database のサービス レベルの各パフォーマンス レベルの DTU 内でシステムを最大限に活用することが重要です。物理データベースに適切な設計を選択すると、個々のクエリの待ち時間とスケール単位で処理可能な同時要求のスループットを大幅に改善し、クエリを満たすために必要なコストを最小限に抑えることができます。インデックス不足の DMV に関する詳細については、「[sys.dm\_db\_missing\_index\_details](https://msdn.microsoft.com/library/ms345434.aspx)」を参照してください。

### クエリ調整/ヒント
Azure SQL Database 内のクエリ オプティマイザーは従来の SQL Server クエリ オプティマイザーと似ています。クエリを調整し、クエリ オプティマイザーの推論モデル制約を理解するベスト プラクティスのほとんどは Azure SQL Database にも適用されます。Azure SQL Database のクエリを調整すると、総リソース要求を減らせる場合があります。また、下位のパフォーマンス レベルで実行できるため、調整されていない場合に比べて低コストでアプリケーションを実行できます。

SQL Server で観察される共通例で、Azure SQL Database にも適用できるものの 1 つは、コンパイル中、より最適なプランを作成するためにパラメーターを「sniffed (探り出す)」方法に関連します。パラメーター スニッフィングは、より最適なクエリ プランを作成する目的でクエリをコンパイルするとき、クエリ オプティマイザーがパラメーターの現在値を考慮するプロセスです。この方針で、多くの場合、パラメーター値に関する知識なしでコンパイルされたプランより大幅に速いクエリ プランが作成されますが、現在の SQL Server/Azure SQL Database の動作は完全ではありません。パラメーターを探り出せない場合があります。また、パラメーターが検索されても、ある作業負荷のフルセットのパラメーター値に対し、生成されたプランは次善となる場合があります。Microsoft はクエリ ヒント (指示) を追加しています。それを利用すれば、意図をより慎重に指定し、パラメーター スニッフィングの既定動作を上書きできます。多くの場合、SQL Server/Azure SQL Database の既定の動作ではお客様の作業負荷に完全に対応できない問題を解消するのにヒントが役立ちます。

次の例は、パフォーマンス要件とリソース要件の両方で次善となるプランをクエリ プロセッサが生成するしくみと、Azure SQL Database でクエリ ヒントを利用し、クエリ ランタイムを短縮し、リソース要件を減らすしくみを示しています。

次はサンプル セットアップです。

	DROP TABLE psptest1;
	CREATE TABLE psptest1(col1 int primary key identity, col2 int, col3 binary(200));

	DECLARE @a int = 0;
	SET NOCOUNT ON;
	BEGIN TRANSACTION
	WHILE @a < 20000
	BEGIN
	    INSERT INTO psptest1(col2) values (1);
	    INSERT INTO psptest1(col2) values (@a);
	    SET @a += 1;
	END
	COMMIT TRANSACTION
	CREATE INDEX i1 on psptest1(col2);
	GO

	CREATE PROCEDURE psp1 (@param1 int)
	AS
	BEGIN
	    INSERT INTO t1 SELECT * FROM psptest1
	    WHERE col2 = @param1
	    ORDER BY col2;
	END
	GO

	CREATE PROCEDURE psp2 (@param2 int)
	AS
	BEGIN
	    INSERT INTO t1 SELECT * FROM psptest1 WHERE col2 = @param2
	    ORDER BY col2
	    OPTION (OPTIMIZE FOR (@param2 UNKNOWN))
	END
	GO

	CREATE TABLE t1 (col1 int primary key, col2 int, col3 binary(200));
	GO

このセットアップ コードでは、傾斜データ分布を含むテーブルが作成されます。最適なクエリ プランは、選択されているパラメーターによって異なります。残念ながら、プラン キャッシング動作は常に最も一般的なパラメーター値に基づいてクエリを再コンパイルするとは限りません。つまり、別のプランのほうが平均的プランとしてより良い選択になる場合でも、次善プランがキャッシュされ、多くの値に使用される可能性があります。次に、そのうちの 1 つに特殊なクエリ ヒントが含まれることを除いて、同じストアド プロシージャが 2 つ作成されます。

**例 (パート 1):**

	-- Prime Procedure Cache with scan plan
	EXEC psp1 @param1=1;
	TRUNCATE TABLE t1;

	-- Iterate multiple times to show the performance difference
	DECLARE @i int = 0;
	WHILE @i < 1000
	BEGIN
	    EXEC psp1 @param1=2;
	    TRUNCATE TABLE t1;
	    SET @i += 1;
	END

**例 (パート 2 – この部分を試す前に 10 分間お待ちください。結果的に生成されるテレメトリ データが明らかに変わります):**

	EXEC psp2 @param2=1;
	TRUNCATE TABLE t1;

	DECLARE @i int = 0;
	WHILE @i < 1000
	BEGIN
	    EXEC psp2 @param2=2;
	    TRUNCATE TABLE t1;
	    SET @i += 1;
	END

この例の各パートで、(テスト データ セットに十分な関連負荷を生成するために) パラメーター化された挿入ステートメントが 1000 回実行されます。ストアド プロシージャを実行するとき、クエリ プロセッサは、その最初のコンパイル中にプロシージャに渡されるパラメーター値を調べます (これがパラメーターの「スニッフィング」です)。結果的に生成されたプランがキャッシュされ、パラメーター値が異なる場合でも、後の呼び出しで使用されます。その結果、最適なプランが使用されないことがあります。クエリが最初にコンパイルされたときのケースではなく、平均的ケースに最適なプランを選択するようにお客様がオプティマイザーを調整しなければならないこともあります。この例では、最初のプランは、パラメーターに一致する各値を見つけるためにすべての行を読み込む "スキャン" プランを生成します。

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_1.png)

値 1 でプロシージャを実行したので、結果的に生成されたプランは 1 に対して最適になりますが、テーブルにあるその他のすべての値に対しては次善となります。各プランを無作為に選択した場合、結果として得られる動作は希望の動作とは異なるものになります。そのプランがより低速で実行され、多くのリソースを使用するためです。

「SET STATISTICS IO ON」でテストを実行すると、内部でこの例で行われた論理スキャン作業が表示されます。このプランで 1148 件の読み取りが行われたことがわかります (平均的なケースで返される行がたった 1 つの場合、これは効率的ではありません)。

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_2.png)

例の 2 つ目の部分では、クエリ ヒントを利用し、コンパイル プロセス中に特定の値を使用するようにオプティマイザーに伝えます。この場合、パラメーターとして渡される値を無視し、代わりに「UNKNOWN」を想定するようにクエリ プロセッサに強制します。つまり、テーブルの平均頻度を持つ値です (傾斜を無視します)。結果的に生成されるプランはシーク ベースのプランであり、この例のパート 1 のプランに比べて概して速く、使用するリソースが少なくなります。

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_3.png)

この影響は **sys.resource\_stats** テーブルを調べることでわかります (テストを実行してからデータがテーブルに入力されるまでの間に遅延があります)。この例の場合、パート 1 は 22:25:00 の時間枠で実行され、パート 2 は 22:35:00 の時間枠で実行されます。早いほうの時間枠では遅いほうの時間枠に比べてその時間枠のリソースがより多く使用されることに注意してください (プランの効率性改善に起因)。

	SELECT TOP 1000 *
	FROM sys.resource_stats
	WHERE database_name = 'resource1'
	ORDER BY start_time DESC

![クエリ調整](./media/sql-database-performance-guidance/query_tuning_4.png)

>[AZURE.NOTE] ここで使用されている例は意図的に小規模にしてありますが、次善パラメーターの影響は、特に大規模データベースで、相当大きくなります。極端なところ、速い場合は数秒単位、遅い場合は数時間単位になります。

**sys.resource\_stats** を調べれば、あるテストのリソースが他のテストに比べてより多いリソースを使用するか、より少ないリソースを使用するかがわかります。データを比較するときは、**sys.resource\_stats** ビューで同じ 5 分の時間枠グループに入らないように十分な時間を空けてテストを分けます。この演習の目標は、使用される合計リソースを最小限に抑えることであり、ピーク リソースを最小限に抑えることではありません。一般的に、待ち時間のコードの一部を最適化すると、リソースの消費量も減ります。クエリ ヒントを使用する場合は、アプリケーションで検討される変更が必要な変更であること、およびアプリケーション利用者のカスタマー エクスペリエンスに悪影響が及ばないことを確認してください。

ワークロードに一連の反復的なクエリが含まれる場合は、データベースをホストするために必要な最小リソース サイズ単位を把握できるため、大抵、そのようなプラン選択肢の最適性を理解して検証することは合理的です。検証後、折に触れてこれらのプランを調べれば、劣化を回避できます。クエリ ヒントの詳細については、「[クエリ ヒント (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx)」を参照してください。

### データベース間のシャーディング
Azure SQL Database は汎用ハードウェアで実行されるため、従来のオンプレミス SQL Server インストールと比べ、1 つのデータベースに対する容量限度が低くなります。そのため、Azure SQL Database でデータベース操作が 1 つのデータベースの上限に収まらないときにシャーディング手法を使用して複数のデータベースにデータベース操作を分散しているユーザーもいます。現在、Azure SQL Database でシャーディング手法を利用するお客様の大半は、1 つの次元のデータを複数のデータベースで分割します。この手法は、OLTP アプリケーションは、多くの場合、スキーマ内の 1 行またはほんの数行からなるグループにのみ適用されるトランザクションを実行することを理解した上で行われます。

>[AZURE.NOTE] SQL Database にシャーディングを支援するライブラリが追加されました。詳細については、「[エラスティック データベース クライアント ライブラリの概要](sql-database-elastic-database-client-library.md)」をご覧ください。

たとえば、(SQL Server 付属の従来のサンプル Northwind データベースのように) あるデータベースに顧客、注文、注文詳細が含まれる場合、注文と注文詳細が関連している顧客をグループにまとめ、1 つのデータベース内に留めることで、このデータを複数のデータベースに分割できます。アプリケーションはデータベース間で顧客を分割し、効果的に負荷を分散します。シャーディングにより、お客様がデータベース サイズの上限を回避できるだけでなく、個々のデータベースがその DTU に収まる限り、各パフォーマンス レベルの上限を大幅に超えるワークロードを Azure SQL Database で処理できます。

データベース シャーディングはソリューションの総リソース容量を減らしませんが、この手法は複数のデータベースにまたがる大規模ソリューションで非常に効果的であり、各データベースを異なるパフォーマンス レベルで実行し、リソース要件の高い、大規模で「効果的な」データベースをサポートできます。

### 機能的パーティション分割
SQL Server ユーザーは、多くの場合、1 台のデータベースのさまざまな機能を組み合わせます。たとえば、アプリケーションに店舗の在庫を管理するロジックが含まれている場合、そのデータベースには、在庫に関連付けられているロジック、購買発注の追跡、ストアド プロシージャ、月末報告を管理するインデックス付きビュー/具体化されたビュー、その他の機能が含まれていることがあります。この手法には、バックアップなどのデータベース操作を簡単に管理できるという利点がありますが、アプリケーションの機能全体でピーク負荷を処理できるようにハードウェアのサイズを調整する必要もあります。

Azure SQL Database 内で使用されるスケールアウト アーキテクチャ内では、アプリケーションの異なる機能を複数のデータベースに分割すると有効です。それにより、それぞれを個別にスケール調整できます。管理者は、アプリケーションがビジー状態になった (データベースの負荷が増えた) 時点で、アプリケーション内の機能ごとにパフォーマンス レベルを個別に選択できます。制約はありますが、複数のコンピューター間で負荷を分散することで、アプリケーションの処理能力を 1 台の汎用コンピューター以上に上げることがこのアーキテクチャで可能になります。

### クエリの一括処理
頻繁にアドホック クエリを実行し、データにアクセスするアプリケーションの場合、アプリケーション層と Azure SQL Database 層の間のネットワーク通信の応答に相当の時間が費やされます。アプリケーションと Azure SQL Database が同じデータ センターに存在する場合でも、データ アクセス操作の数が多ければ、この 2 つの間のネットワーク待ち時間が長くなります。このようなデータ アクセス操作のネットワーク ラウンド トリップを減らすために、アプリケーションの開発者は、アドホック クエリを一括処理するか、ストアド プロシージャにコンパイルすることを検討してください。アドホック クエリを一括処理すると、複数のクエリを 1 つの大きなバッチとして 1 回のトリップで Azure SQL Database に送信できます。アドホック クエリをストアド プロシージャにコンパイルすると、一括処理と同じ結果が得られます。ストアド プロシージャを利用する場合、同じストアド プロシージャを後で実行するときのために、クエリ プランが Azure SQL Database にキャッシュされる機会が増えるという利点もあります。

一部のアプリケーションでは、書き込みが集中します。場合によっては、書き込みを一括処理する方法を検討することで、データベースの IO 総負荷を減らせることがあります。それは、多くの場合、ストアド プロシージャやアドホック バッチ内で、自動コミット トランザクションの代わりに、明示的トランザクションを使用するのと同じくらい単純になります。利用できるさまざまな手法の評価は「[Azure の SQL Database アプリケーションの一括処理手法](https://msdn.microsoft.com/library/windowsazure/dn132615.aspx)」にあります。独自の作業負荷を試し、一括処理に最適なモデルを探してください。モデルによっては、トランザクションの整合性がわずかに変わることがあります。リソース使用を最小限に抑える作業負荷を見つけるには、整合性と性能の適度なバランスを見つける必要があります。

### アプリケーション層のキャッシュ
データベース アプリケーションによっては、作業負荷の大半が読み取りになります。キャッシュ層を利用すれば、データベースの負荷を減らすことができます。また、Azure SQL Database を利用するデータベースを支援するために必要なパフォーマンス レベルを下げられる可能性もあります。[Azure Redis Cache](https://azure.microsoft.com/services/cache/) を利用すれば、読み取り集中型の作業負荷に対して、データを 1 回読み込み (あるいは、構成方法によっては、アプリケーション層コンピューターごとに 1 回)、Azure SQL Database の外にそのデータを保存することができます。それにより、データベースの負荷 (CPU と読み取り IO) を減らすことができますが、トランザクションの整合性が影響を受けます。キャッシュから読み込まれるデータはデータベースのデータよりも古いことがあるためです。多くのアプリケーションでは一定の不整合が許容されますが、すべての作業負荷で許容されるとは限りません。アプリケーション層のキャッシュ手法を採用する前に、あらゆるアプリケーション要件を完全に理解してください。

## 次のステップ

- サービス レベルの詳細については、[サービス レベル](sql-database-service-tiers.md)に関するトピックを参照してください。
- エラスティック プールの詳細については、[エラスティック プール](sql-database-elastic-pool.md)に関するトピックを参照してください。
- パフォーマンスとエラスティック プールの詳細については、[エラスティック プールのパフォーマンスに関する考慮事項](sql-database-elastic-pool-guidance.md)に関するトピックを参照してください。

<!---HONumber=AcomDC_0914_2016-->